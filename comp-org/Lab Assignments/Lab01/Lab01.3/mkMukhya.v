//
// Generated by Bluespec Compiler, version 2011.06.D (build 24470, 2011-06-30)
//
// On Sat Sep  3 00:22:42 IST 2011
//
// Method conflict info:
// Method: retAnodeSelected
// Conflict-free: retAnodeSelected, retSegmentData
// Sequenced before (restricted): updateInput
//
// Method: retSegmentData
// Conflict-free: retAnodeSelected, retSegmentData
// Sequenced before (restricted): updateInput
//
// Method: updateInput
// Sequenced before (restricted): updateInput
// Sequenced after (restricted): retAnodeSelected, retSegmentData
//
//
// Ports:
// Name                         I/O  size props
// retAnodeSelected               O     4
// RDY_retAnodeSelected           O     1 const
// retSegmentData                 O     7 reg
// RDY_retSegmentData             O     1 const
// RDY_updateInput                O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// updateInput_inp                I     2 reg
// EN_updateInput                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkMukhya(CLK,
		RST_N,

		retAnodeSelected,
		RDY_retAnodeSelected,

		retSegmentData,
		RDY_retSegmentData,

		updateInput_inp,
		EN_updateInput,
		RDY_updateInput);
  input  CLK;
  input  RST_N;

  // value method retAnodeSelected
  output [3 : 0] retAnodeSelected;
  output RDY_retAnodeSelected;

  // value method retSegmentData
  output [6 : 0] retSegmentData;
  output RDY_retSegmentData;

  // action method updateInput
  input  [1 : 0] updateInput_inp;
  input  EN_updateInput;
  output RDY_updateInput;

  // signals for module outputs
  reg [3 : 0] retAnodeSelected;
  wire [6 : 0] retSegmentData;
  wire RDY_retAnodeSelected, RDY_retSegmentData, RDY_updateInput;

  // register anodeSelected
  reg [3 : 0] anodeSelected;
  wire [3 : 0] anodeSelected$D_IN;
  wire anodeSelected$EN;

  // register counterDisplaySelected
  reg [11 : 0] counterDisplaySelected;
  wire [11 : 0] counterDisplaySelected$D_IN;
  wire counterDisplaySelected$EN;

  // register displaySelected
  reg [1 : 0] displaySelected;
  wire [1 : 0] displaySelected$D_IN;
  wire displaySelected$EN;

  // register inputFromSwitches
  reg [1 : 0] inputFromSwitches;
  wire [1 : 0] inputFromSwitches$D_IN;
  wire inputFromSwitches$EN;

  // register segmentData
  reg [6 : 0] segmentData;
  reg [6 : 0] segmentData$D_IN;
  wire segmentData$EN;

  // ports of submodule h2s0
  wire [6 : 0] h2s0$decode;
  wire [3 : 0] h2s0$decode_hex;

  // ports of submodule h2s1
  wire [6 : 0] h2s1$decode;
  wire [3 : 0] h2s1$decode_hex;

  // ports of submodule h2s10
  wire [6 : 0] h2s10$decode;
  wire [3 : 0] h2s10$decode_hex;

  // ports of submodule h2s11
  wire [6 : 0] h2s11$decode;
  wire [3 : 0] h2s11$decode_hex;

  // ports of submodule h2s12
  wire [6 : 0] h2s12$decode;
  wire [3 : 0] h2s12$decode_hex;

  // ports of submodule h2s13
  wire [6 : 0] h2s13$decode;
  wire [3 : 0] h2s13$decode_hex;

  // ports of submodule h2s14
  wire [6 : 0] h2s14$decode;
  wire [3 : 0] h2s14$decode_hex;

  // ports of submodule h2s15
  wire [6 : 0] h2s15$decode;
  wire [3 : 0] h2s15$decode_hex;

  // ports of submodule h2s2
  wire [6 : 0] h2s2$decode;
  wire [3 : 0] h2s2$decode_hex;

  // ports of submodule h2s3
  wire [6 : 0] h2s3$decode;
  wire [3 : 0] h2s3$decode_hex;

  // ports of submodule h2s4
  wire [6 : 0] h2s4$decode;
  wire [3 : 0] h2s4$decode_hex;

  // ports of submodule h2s5
  wire [6 : 0] h2s5$decode;
  wire [3 : 0] h2s5$decode_hex;

  // ports of submodule h2s6
  wire [6 : 0] h2s6$decode;
  wire [3 : 0] h2s6$decode_hex;

  // ports of submodule h2s7
  wire [6 : 0] h2s7$decode;
  wire [3 : 0] h2s7$decode_hex;

  // ports of submodule h2s8
  wire [6 : 0] h2s8$decode;
  wire [3 : 0] h2s8$decode_hex;

  // ports of submodule h2s9
  wire [6 : 0] h2s9$decode;
  wire [3 : 0] h2s9$decode_hex;

  // remaining internal signals
  reg [6 : 0] CASE_displaySelected_h2s11decode_0b1_h2s9dec_ETC__q3,
	      CASE_displaySelected_h2s3decode_0b0_h2s0deco_ETC__q1,
	      CASE_displaySelected_h2s7decode_0b1_h2s5deco_ETC__q2,
	      IF_displaySelected_EQ_0b1_THEN_h2s13_decode_0b_ETC___d54;

  // value method retAnodeSelected
  always@(displaySelected)
  begin
    case (displaySelected)
      2'b0: retAnodeSelected = 4'b1110;
      2'b01: retAnodeSelected = 4'b1101;
      2'b10: retAnodeSelected = 4'b1011;
      2'd3: retAnodeSelected = 4'b0111;
    endcase
  end
  assign RDY_retAnodeSelected = 1'd1 ;

  // value method retSegmentData
  assign retSegmentData = segmentData ;
  assign RDY_retSegmentData = 1'd1 ;

  // action method updateInput
  assign RDY_updateInput = 1'd1 ;

  // submodule h2s0
  mkh2s h2s0(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s0$decode_hex),
	     .decode(h2s0$decode),
	     .RDY_decode());

  // submodule h2s1
  mkh2s h2s1(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s1$decode_hex),
	     .decode(h2s1$decode),
	     .RDY_decode());

  // submodule h2s10
  mkh2s h2s10(.CLK(CLK),
	      .RST_N(RST_N),
	      .decode_hex(h2s10$decode_hex),
	      .decode(h2s10$decode),
	      .RDY_decode());

  // submodule h2s11
  mkh2s h2s11(.CLK(CLK),
	      .RST_N(RST_N),
	      .decode_hex(h2s11$decode_hex),
	      .decode(h2s11$decode),
	      .RDY_decode());

  // submodule h2s12
  mkh2s h2s12(.CLK(CLK),
	      .RST_N(RST_N),
	      .decode_hex(h2s12$decode_hex),
	      .decode(h2s12$decode),
	      .RDY_decode());

  // submodule h2s13
  mkh2s h2s13(.CLK(CLK),
	      .RST_N(RST_N),
	      .decode_hex(h2s13$decode_hex),
	      .decode(h2s13$decode),
	      .RDY_decode());

  // submodule h2s14
  mkh2s h2s14(.CLK(CLK),
	      .RST_N(RST_N),
	      .decode_hex(h2s14$decode_hex),
	      .decode(h2s14$decode),
	      .RDY_decode());

  // submodule h2s15
  mkh2s h2s15(.CLK(CLK),
	      .RST_N(RST_N),
	      .decode_hex(h2s15$decode_hex),
	      .decode(h2s15$decode),
	      .RDY_decode());

  // submodule h2s2
  mkh2s h2s2(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s2$decode_hex),
	     .decode(h2s2$decode),
	     .RDY_decode());

  // submodule h2s3
  mkh2s h2s3(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s3$decode_hex),
	     .decode(h2s3$decode),
	     .RDY_decode());

  // submodule h2s4
  mkh2s h2s4(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s4$decode_hex),
	     .decode(h2s4$decode),
	     .RDY_decode());

  // submodule h2s5
  mkh2s h2s5(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s5$decode_hex),
	     .decode(h2s5$decode),
	     .RDY_decode());

  // submodule h2s6
  mkh2s h2s6(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s6$decode_hex),
	     .decode(h2s6$decode),
	     .RDY_decode());

  // submodule h2s7
  mkh2s h2s7(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s7$decode_hex),
	     .decode(h2s7$decode),
	     .RDY_decode());

  // submodule h2s8
  mkh2s h2s8(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s8$decode_hex),
	     .decode(h2s8$decode),
	     .RDY_decode());

  // submodule h2s9
  mkh2s h2s9(.CLK(CLK),
	     .RST_N(RST_N),
	     .decode_hex(h2s9$decode_hex),
	     .decode(h2s9$decode),
	     .RDY_decode());

  // register anodeSelected
  assign anodeSelected$D_IN = 4'h0 ;
  assign anodeSelected$EN = 1'b0 ;

  // register counterDisplaySelected
  assign counterDisplaySelected$D_IN = counterDisplaySelected + 12'd1 ;
  assign counterDisplaySelected$EN = 1'd1 ;

  // register displaySelected
  assign displaySelected$D_IN = displaySelected + 2'b01 ;
  assign displaySelected$EN = counterDisplaySelected == 12'd0 ;

  // register inputFromSwitches
  assign inputFromSwitches$D_IN = updateInput_inp ;
  assign inputFromSwitches$EN = EN_updateInput ;

  // register segmentData
  always@(inputFromSwitches or
	  displaySelected or
	  h2s12$decode or
	  IF_displaySelected_EQ_0b1_THEN_h2s13_decode_0b_ETC___d54 or
	  CASE_displaySelected_h2s3decode_0b0_h2s0deco_ETC__q1 or
	  h2s4$decode or
	  CASE_displaySelected_h2s7decode_0b1_h2s5deco_ETC__q2 or
	  h2s8$decode or CASE_displaySelected_h2s11decode_0b1_h2s9dec_ETC__q3)
  begin
    case (inputFromSwitches)
      2'b0:
	  segmentData$D_IN =
	      CASE_displaySelected_h2s3decode_0b0_h2s0deco_ETC__q1;
      2'b01:
	  segmentData$D_IN =
	      (displaySelected == 2'b0) ?
		h2s4$decode :
		CASE_displaySelected_h2s7decode_0b1_h2s5deco_ETC__q2;
      2'b10:
	  segmentData$D_IN =
	      (displaySelected == 2'b0) ?
		h2s8$decode :
		CASE_displaySelected_h2s11decode_0b1_h2s9dec_ETC__q3;
      2'd3:
	  segmentData$D_IN =
	      (displaySelected == 2'b0) ?
		h2s12$decode :
		IF_displaySelected_EQ_0b1_THEN_h2s13_decode_0b_ETC___d54;
    endcase
  end
  assign segmentData$EN = 1'b1 ;

  // submodule h2s0
  assign h2s0$decode_hex = 4'b0 ;

  // submodule h2s1
  assign h2s1$decode_hex = 4'b0010 ;

  // submodule h2s10
  assign h2s10$decode_hex = 4'b0011 ;

  // submodule h2s11
  assign h2s11$decode_hex = 4'b0 ;

  // submodule h2s12
  assign h2s12$decode_hex = 4'b0111 ;

  // submodule h2s13
  assign h2s13$decode_hex = 4'b0 ;

  // submodule h2s14
  assign h2s14$decode_hex = 4'b1000 ;

  // submodule h2s15
  assign h2s15$decode_hex = 4'b0 ;

  // submodule h2s2
  assign h2s2$decode_hex = 4'b0010 ;

  // submodule h2s3
  assign h2s3$decode_hex = 4'b1100 ;

  // submodule h2s4
  assign h2s4$decode_hex = 4'b0 ;

  // submodule h2s5
  assign h2s5$decode_hex = 4'b1001 ;

  // submodule h2s6
  assign h2s6$decode_hex = 4'b0010 ;

  // submodule h2s7
  assign h2s7$decode_hex = 4'b0 ;

  // submodule h2s8
  assign h2s8$decode_hex = 4'b0100 ;

  // submodule h2s9
  assign h2s9$decode_hex = 4'b0001 ;

  // remaining internal signals
  always@(displaySelected or h2s15$decode or h2s13$decode or h2s14$decode)
  begin
    case (displaySelected)
      2'b01:
	  IF_displaySelected_EQ_0b1_THEN_h2s13_decode_0b_ETC___d54 =
	      h2s13$decode;
      2'b10:
	  IF_displaySelected_EQ_0b1_THEN_h2s13_decode_0b_ETC___d54 =
	      h2s14$decode;
      default: IF_displaySelected_EQ_0b1_THEN_h2s13_decode_0b_ETC___d54 =
		   h2s15$decode;
    endcase
  end
  always@(displaySelected or
	  h2s3$decode or h2s0$decode or h2s1$decode or h2s2$decode)
  begin
    case (displaySelected)
      2'b0:
	  CASE_displaySelected_h2s3decode_0b0_h2s0deco_ETC__q1 = h2s0$decode;
      2'b01:
	  CASE_displaySelected_h2s3decode_0b0_h2s0deco_ETC__q1 = h2s1$decode;
      2'b10:
	  CASE_displaySelected_h2s3decode_0b0_h2s0deco_ETC__q1 = h2s2$decode;
      2'd3:
	  CASE_displaySelected_h2s3decode_0b0_h2s0deco_ETC__q1 = h2s3$decode;
    endcase
  end
  always@(displaySelected or h2s7$decode or h2s5$decode or h2s6$decode)
  begin
    case (displaySelected)
      2'b01:
	  CASE_displaySelected_h2s7decode_0b1_h2s5deco_ETC__q2 = h2s5$decode;
      2'b10:
	  CASE_displaySelected_h2s7decode_0b1_h2s5deco_ETC__q2 = h2s6$decode;
      default: CASE_displaySelected_h2s7decode_0b1_h2s5deco_ETC__q2 =
		   h2s7$decode;
    endcase
  end
  always@(displaySelected or h2s11$decode or h2s9$decode or h2s10$decode)
  begin
    case (displaySelected)
      2'b01:
	  CASE_displaySelected_h2s11decode_0b1_h2s9dec_ETC__q3 = h2s9$decode;
      2'b10:
	  CASE_displaySelected_h2s11decode_0b1_h2s9dec_ETC__q3 = h2s10$decode;
      default: CASE_displaySelected_h2s11decode_0b1_h2s9dec_ETC__q3 =
		   h2s11$decode;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        anodeSelected <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counterDisplaySelected <= `BSV_ASSIGNMENT_DELAY 12'd0;
	displaySelected <= `BSV_ASSIGNMENT_DELAY 2'd0;
	inputFromSwitches <= `BSV_ASSIGNMENT_DELAY 2'd0;
	segmentData <= `BSV_ASSIGNMENT_DELAY 7'd0;
      end
    else
      begin
        if (anodeSelected$EN)
	  anodeSelected <= `BSV_ASSIGNMENT_DELAY anodeSelected$D_IN;
	if (counterDisplaySelected$EN)
	  counterDisplaySelected <= `BSV_ASSIGNMENT_DELAY
	      counterDisplaySelected$D_IN;
	if (displaySelected$EN)
	  displaySelected <= `BSV_ASSIGNMENT_DELAY displaySelected$D_IN;
	if (inputFromSwitches$EN)
	  inputFromSwitches <= `BSV_ASSIGNMENT_DELAY inputFromSwitches$D_IN;
	if (segmentData$EN)
	  segmentData <= `BSV_ASSIGNMENT_DELAY segmentData$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    anodeSelected = 4'hA;
    counterDisplaySelected = 12'hAAA;
    displaySelected = 2'h2;
    inputFromSwitches = 2'h2;
    segmentData = 7'h2A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMukhya

