//
// Generated by Bluespec Compiler, version 2011.06.D (build 24470, 2011-06-30)
//
// On Sun Sep  4 23:14:33 IST 2011
//
// Method conflict info:
// Method: retled
// Conflict-free: retled, retsegm
//
// Method: retsegm
// Conflict-free: retled, retsegm
//
//
// Ports:
// Name                         I/O  size props
// retled                         O     7 reg
// RDY_retled                     O     1 const
// retsegm                        O     4 reg
// RDY_retsegm                    O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkCtr(CLK,
	     RST_N,

	     retled,
	     RDY_retled,

	     retsegm,
	     RDY_retsegm);
  input  CLK;
  input  RST_N;

  // value method retled
  output [6 : 0] retled;
  output RDY_retled;

  // value method retsegm
  output [3 : 0] retsegm;
  output RDY_retsegm;

  // signals for module outputs
  wire [6 : 0] retled;
  wire [3 : 0] retsegm;
  wire RDY_retled, RDY_retsegm;

  // register c
  reg [24 : 0] c;
  wire [24 : 0] c$D_IN;
  wire c$EN;

  // register hex
  reg [3 : 0] hex;
  wire [3 : 0] hex$D_IN;
  wire hex$EN;

  // register led
  reg [6 : 0] led;
  wire [6 : 0] led$D_IN;
  wire led$EN;

  // register segm
  reg [3 : 0] segm;
  wire [3 : 0] segm$D_IN;
  wire segm$EN;

  // ports of submodule h2s
  wire [6 : 0] h2s$decode;
  wire [3 : 0] h2s$decode_hex, h2s$dispsegment;

  // remaining internal signals
  wire [3 : 0] x__h396;

  // value method retled
  assign retled = led ;
  assign RDY_retled = 1'd1 ;

  // value method retsegm
  assign retsegm = segm ;
  assign RDY_retsegm = 1'd1 ;

  // submodule h2s
  mkh2s h2s(.CLK(CLK),
	    .RST_N(RST_N),
	    .decode_hex(h2s$decode_hex),
	    .decode(h2s$decode),
	    .RDY_decode(),
	    .dispsegment(h2s$dispsegment),
	    .RDY_dispsegment());

  // register c
  assign c$D_IN = c + 25'd1 ;
  assign c$EN = 1'd1 ;

  // register hex
  assign hex$D_IN = (hex == 4'b0011) ? 4'b0 : x__h396 ;
  assign hex$EN = c == 25'd0 ;

  // register led
  assign led$D_IN = h2s$decode ;
  assign led$EN = c == 25'd0 ;

  // register segm
  assign segm$D_IN = h2s$dispsegment ;
  assign segm$EN = 1'd1 ;

  // submodule h2s
  assign h2s$decode_hex = hex ;

  // remaining internal signals
  assign x__h396 = hex + 4'b0001 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        c <= `BSV_ASSIGNMENT_DELAY 25'd0;
	hex <= `BSV_ASSIGNMENT_DELAY 4'd0;
	led <= `BSV_ASSIGNMENT_DELAY 7'd0;
	segm <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (c$EN) c <= `BSV_ASSIGNMENT_DELAY c$D_IN;
	if (hex$EN) hex <= `BSV_ASSIGNMENT_DELAY hex$D_IN;
	if (led$EN) led <= `BSV_ASSIGNMENT_DELAY led$D_IN;
	if (segm$EN) segm <= `BSV_ASSIGNMENT_DELAY segm$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    c = 25'h0AAAAAA;
    hex = 4'hA;
    led = 7'h2A;
    segm = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCtr

