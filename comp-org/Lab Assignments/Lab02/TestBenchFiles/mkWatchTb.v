//
// Generated by Bluespec Compiler, version 2011.06.D (build 24470, 2011-06-30)
//
// On Sat Sep 24 01:40:35 IST 2011
//
// Method conflict info:
// (none)
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkWatchTb(CLK,
		 RST_N);
  input  CLK;
  input  RST_N;

  // register counterDisplay
  reg [14 : 0] counterDisplay;
  wire [14 : 0] counterDisplay$D_IN;
  wire counterDisplay$EN;

  // register counterMode
  reg [17 : 0] counterMode;
  wire [17 : 0] counterMode$D_IN;
  wire counterMode$EN;

  // register showing
  reg [1 : 0] showing;
  wire [1 : 0] showing$D_IN;
  wire showing$EN;

  // ports of submodule watch
  wire [6 : 0] watch$retSegmentData;
  wire [5 : 0] watch$updateInput_swtchs;
  wire [3 : 0] watch$retAnodeSelected;
  wire [2 : 0] watch$updateInput_btns;
  wire watch$EN_updateInput;

  // submodule watch
  mkWatch watch(.CLK(CLK),
		.RST_N(RST_N),
		.updateInput_btns(watch$updateInput_btns),
		.updateInput_swtchs(watch$updateInput_swtchs),
		.EN_updateInput(watch$EN_updateInput),
		.retAnodeSelected(watch$retAnodeSelected),
		.RDY_retAnodeSelected(),
		.retSegmentData(watch$retSegmentData),
		.RDY_retSegmentData(),
		.RDY_updateInput(),
		.retLEDSignals(),
		.RDY_retLEDSignals());

  // register counterDisplay
  assign counterDisplay$D_IN = counterDisplay + 15'b000000000000001 ;
  assign counterDisplay$EN = 1'd1 ;

  // register counterMode
  assign counterMode$D_IN = counterMode + 18'd1 ;
  assign counterMode$EN = 1'd1 ;

  // register showing
  assign showing$D_IN = showing + 2'd1 ;
  assign showing$EN = counterMode == 18'd0 ;

  // submodule watch
  assign watch$updateInput_btns = 3'b001 ;
  assign watch$updateInput_swtchs = 6'b0 ;
  assign watch$EN_updateInput = 1'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        counterDisplay <= `BSV_ASSIGNMENT_DELAY 15'd0;
	counterMode <= `BSV_ASSIGNMENT_DELAY 18'd0;
	showing <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (counterDisplay$EN)
	  counterDisplay <= `BSV_ASSIGNMENT_DELAY counterDisplay$D_IN;
	if (counterMode$EN)
	  counterMode <= `BSV_ASSIGNMENT_DELAY counterMode$D_IN;
	if (showing$EN) showing <= `BSV_ASSIGNMENT_DELAY showing$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    counterDisplay = 15'h2AAA;
    counterMode = 18'h2AAAA;
    showing = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (counterDisplay == 15'd0)
	$display("%b %b %d  ",
		 watch$retAnodeSelected,
		 watch$retSegmentData,
		 (watch$retSegmentData == 7'b0000001) ?
		   4'd0 :
		   ((watch$retSegmentData == 7'b1001111) ?
		      4'd1 :
		      ((watch$retSegmentData == 7'b0010010) ?
			 4'd2 :
			 ((watch$retSegmentData == 7'b0000110) ?
			    4'd3 :
			    ((watch$retSegmentData == 7'b1001100) ?
			       4'd4 :
			       ((watch$retSegmentData == 7'b0100100) ?
				  4'd5 :
				  ((watch$retSegmentData == 7'b0100000) ?
				     4'd6 :
				     ((watch$retSegmentData == 7'b0001111) ?
					4'd7 :
					((watch$retSegmentData == 7'b0) ?
					   4'd8 :
					   ((watch$retSegmentData ==
					     7'b0000100) ?
					      4'd9 :
					      4'd10))))))))));
    if (RST_N) if (counterMode == 18'd0) $display("Changing mode to");
    if (RST_N)
      if (counterMode == 18'd0 && showing == 2'b0) $display("Hours:Minutes");
    if (RST_N)
      if (counterMode == 18'd0 && showing == 2'b01)
	$display("Minutes:Seconds");
    if (RST_N)
      if (counterMode == 18'd0 && showing == 2'b10) $display("Alarm");
    if (RST_N)
      if (counterMode == 18'd0 && showing == 2'b11) $display("Stopwatch");
  end
  // synopsys translate_on
endmodule  // mkWatchTb

