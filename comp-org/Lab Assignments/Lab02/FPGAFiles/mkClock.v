//
// Generated by Bluespec Compiler, version 2011.06.D (build 24470, 2011-06-30)
//
// On Sat Sep 24 00:47:35 IST 2011
//
// Method conflict info:
// Method: pause
// Conflict-free: setHH, setMM, setSS
// Sequenced before (restricted): pause, start
// Sequenced after (restricted): dataHHMM, dataMMSS
//
// Method: start
// Conflict-free: setHH, setMM, setSS
// Sequenced before (restricted): start
// Sequenced after (restricted): pause, dataHHMM, dataMMSS
//
// Method: setHH
// Conflict-free: pause, start, setMM, setSS
// Sequenced before (restricted): setHH
// Sequenced after (restricted): dataHHMM, dataMMSS
//
// Method: setMM
// Conflict-free: pause, start, setHH, setSS
// Sequenced before (restricted): setMM
// Sequenced after (restricted): dataHHMM, dataMMSS
//
// Method: setSS
// Conflict-free: pause, start, setHH, setMM
// Sequenced before (restricted): setSS
// Sequenced after (restricted): dataHHMM, dataMMSS
//
// Method: dataHHMM
// Conflict-free: dataHHMM, dataMMSS
// Sequenced before (restricted): pause, start, setHH, setMM, setSS
//
// Method: dataMMSS
// Conflict-free: dataHHMM, dataMMSS
// Sequenced before (restricted): pause, start, setHH, setMM, setSS
//
//
// Ports:
// Name                         I/O  size props
// RDY_pause                      O     1 const
// RDY_start                      O     1 const
// RDY_setHH                      O     1 const
// RDY_setMM                      O     1 const
// RDY_setSS                      O     1 const
// dataHHMM                       O    11 reg
// RDY_dataHHMM                   O     1 const
// dataMMSS                       O    12 reg
// RDY_dataMMSS                   O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// setHH_hh                       I     5
// setMM_mm                       I     6
// setSS_ss                       I     6
// EN_pause                       I     1
// EN_start                       I     1
// EN_setHH                       I     1
// EN_setMM                       I     1
// EN_setSS                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkClock(CLK,
	       RST_N,

	       EN_pause,
	       RDY_pause,

	       EN_start,
	       RDY_start,

	       setHH_hh,
	       EN_setHH,
	       RDY_setHH,

	       setMM_mm,
	       EN_setMM,
	       RDY_setMM,

	       setSS_ss,
	       EN_setSS,
	       RDY_setSS,

	       dataHHMM,
	       RDY_dataHHMM,

	       dataMMSS,
	       RDY_dataMMSS);
  input  CLK;
  input  RST_N;

  // action method pause
  input  EN_pause;
  output RDY_pause;

  // action method start
  input  EN_start;
  output RDY_start;

  // action method setHH
  input  [4 : 0] setHH_hh;
  input  EN_setHH;
  output RDY_setHH;

  // action method setMM
  input  [5 : 0] setMM_mm;
  input  EN_setMM;
  output RDY_setMM;

  // action method setSS
  input  [5 : 0] setSS_ss;
  input  EN_setSS;
  output RDY_setSS;

  // value method dataHHMM
  output [10 : 0] dataHHMM;
  output RDY_dataHHMM;

  // value method dataMMSS
  output [11 : 0] dataMMSS;
  output RDY_dataMMSS;

  // signals for module outputs
  wire [11 : 0] dataMMSS;
  wire [10 : 0] dataHHMM;
  wire RDY_dataHHMM,
       RDY_dataMMSS,
       RDY_pause,
       RDY_setHH,
       RDY_setMM,
       RDY_setSS,
       RDY_start;

  // register decelerator
  reg [25 : 0] decelerator;
  wire [25 : 0] decelerator$D_IN;
  wire decelerator$EN;

  // register hrs
  reg [4 : 0] hrs;
  wire [4 : 0] hrs$D_IN;
  wire hrs$EN;

  // register min
  reg [5 : 0] min;
  wire [5 : 0] min$D_IN;
  wire min$EN;

  // register running
  reg running;
  wire running$D_IN, running$EN;

  // register sec
  reg [5 : 0] sec;
  wire [5 : 0] sec$D_IN;
  wire sec$EN;

  // inputs to muxes for submodule ports
  wire [5 : 0] MUX_min$write_1__VAL_2, MUX_sec$write_1__VAL_2;
  wire [4 : 0] MUX_hrs$write_1__VAL_2;

  // remaining internal signals
  wire [25 : 0] x__h307;
  wire [5 : 0] x__h339, x__h378;
  wire [4 : 0] x__h410;

  // action method pause
  assign RDY_pause = 1'd1 ;

  // action method start
  assign RDY_start = 1'd1 ;

  // action method setHH
  assign RDY_setHH = 1'd1 ;

  // action method setMM
  assign RDY_setMM = 1'd1 ;

  // action method setSS
  assign RDY_setSS = 1'd1 ;

  // value method dataHHMM
  assign dataHHMM = { hrs, min } ;
  assign RDY_dataHHMM = 1'd1 ;

  // value method dataMMSS
  assign dataMMSS = { min, sec } ;
  assign RDY_dataMMSS = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_hrs$write_1__VAL_2 = (hrs == 5'd23) ? 5'd0 : x__h410 ;
  assign MUX_min$write_1__VAL_2 = (min == 6'd59) ? 6'd0 : x__h378 ;
  assign MUX_sec$write_1__VAL_2 = (sec == 6'd59) ? 6'd0 : x__h339 ;

  // register decelerator
  assign decelerator$D_IN = (decelerator == 26'd49999999) ? 26'd0 : x__h307 ;
  assign decelerator$EN = running ;

  // register hrs
  assign hrs$D_IN = EN_setHH ? setHH_hh : MUX_hrs$write_1__VAL_2 ;
  assign hrs$EN =
	     decelerator == 26'd0 && sec == 6'd59 && min == 6'd59 ||
	     EN_setHH ;

  // register min
  assign min$D_IN = EN_setMM ? setMM_mm : MUX_min$write_1__VAL_2 ;
  assign min$EN = decelerator == 26'd0 && sec == 6'd59 || EN_setMM ;

  // register running
  assign running$D_IN = EN_start ;
  assign running$EN = EN_pause || EN_start ;

  // register sec
  assign sec$D_IN = EN_setSS ? setSS_ss : MUX_sec$write_1__VAL_2 ;
  assign sec$EN = EN_setSS || decelerator == 26'd0 ;

  // remaining internal signals
  assign x__h307 = decelerator + 26'd1 ;
  assign x__h339 = sec + 6'd1 ;
  assign x__h378 = min + 6'd1 ;
  assign x__h410 = hrs + 5'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        decelerator <= `BSV_ASSIGNMENT_DELAY 26'd0;
	hrs <= `BSV_ASSIGNMENT_DELAY 5'b01100;
	min <= `BSV_ASSIGNMENT_DELAY 6'd0;
	running <= `BSV_ASSIGNMENT_DELAY 1'd1;
	sec <= `BSV_ASSIGNMENT_DELAY 6'd0;
      end
    else
      begin
        if (decelerator$EN)
	  decelerator <= `BSV_ASSIGNMENT_DELAY decelerator$D_IN;
	if (hrs$EN) hrs <= `BSV_ASSIGNMENT_DELAY hrs$D_IN;
	if (min$EN) min <= `BSV_ASSIGNMENT_DELAY min$D_IN;
	if (running$EN) running <= `BSV_ASSIGNMENT_DELAY running$D_IN;
	if (sec$EN) sec <= `BSV_ASSIGNMENT_DELAY sec$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    decelerator = 26'h2AAAAAA;
    hrs = 5'h0A;
    min = 6'h2A;
    running = 1'h0;
    sec = 6'h2A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkClock

